<wiki:toc />
----
= Examples tutorial =
This section provide explanations about different example scenarios. The scenarios have been selected so that they cover different areas. At the beginning it has been tried to show how the ADC and DAC can be used in GISOO and in the next step the required details for serial communication has been explained. The usage of serial communication also has been shown in a simple example. In the next section the previous simple scenario (water tanks scenario) has been modified to  provide use serial communications in its scenario. In the next section the water-tanks scenario has been extended to show the usage of CTP routing protocol in the routing layer. 
In overall this section provides examples from very simple and basic aspects until advanced ones which also can be considered as tutorial for GISOO.
== Basic Examples ==
=== ADC data transmission in GISOO ==
TinyOS codes: [https://kth-gisoo.googlecode.com/svn/trunk/files/examples/adcreader/ADCReader.zip Download_ADCReader] 

Simulink Model: [https://kth-gisoo.googlecode.com/svn/trunk/files/examples/adcreader/ADCReader_SimulinkModel.zip Download_ADCReader_SimulinkModel] 

This example explains the ADC communication procedure in GISOO. For this example you can download provided TinyOS code which should be used to create the Cooja simulation. Also the designed Simulink model for this scenario is available for download. In the first step after extracting of the TinyOS code you have to compile the code by the following command:(To use this command you the TinyOS should be installed in advanced.) 
{{{
make telosb install
}}}
More explanation about TinyOS and its command can be found in the [http://tinyos.stanford.edu/tinyos-wiki/index.php/TinyOS_Tutorials  TinyOS tutorials]. This code will read the ADC values of ADC0 and ADC1 in the mote every 200 ms and whenever a ADC data is received, the three least significant bits in the ADC0 value are displayed by the motes' LEDs.
After compiling the ADCReader code, you should run a new simulation in Cooja and create a new mote in that simulation environment by using the main.exe file of ADCReader which will be created in the build folder after its compilation. More details about adding mote in Cooja has been explained [https://code.google.com/p/kth-gisoo/wiki/How_to_use_it#Adding_motes_to_the_simulation  here]. Finally you should activated the SimmulinkConnector plug-in for the created mote.
In the next step you have to download the Simulink model and after extract it the simulation is ready. This Simulink model will generate the different values by using the sin function to be read as the ADC value bye the mote. The following figure shows the simulation environment in the Cooja and Simulink.

<p align="center">  
<img src="https://kth-gisoo.googlecode.com/svn/trunk/images/samples/adcreader/ADCReader.png" >
<p>

As it has been shown in the previous picture after running the simulation the Leds will blink according to the data which it could read in the ADC0.
The following picture shows inside of the Cooja platform in the Simulink model which contains one mote with two income one for ADC0 and another one by ADC1.

<p align="center">  
<img src="https://kth-gisoo.googlecode.com/svn/trunk/images/samples/adcreader/ADCReader_CoojaPlatform.png" >
<p>
=== DAC data transmission in GISOO ==
TinyOS codes: [https://kth-gisoo.googlecode.com/svn/trunk/files/examples/dacwriter/DACWriter.zip Download_DACWriter] 

Simulink Model: [https://kth-gisoo.googlecode.com/svn/trunk/files/examples/dacwriter/DACWriter_SimulinkModel.zip  Download_DACWriter_SimulinkModel] 

This example is a sample for DAC communication and similar to the previous example you can download the provided TinyOS code and Simulink model for this example. The provided TinyOS code (DACWriter) will write a counter value on the DAC0 of the mote and whenever the DAC value is written the Led2 will toggle. Following picture shows the Simulink and Cooja environment together. 
<p align="center">  
<img src="https://kth-gisoo.googlecode.com/svn/trunk/images/samples/dacwriter/DACWriter.png" >
<p>

As the previous picture shows the mote generate the counter values and send it over the DAC0. For each DAC value the led2 toggled. On the other side the Simulink will receive this value and show it in the scope.
The following picture shows the amount of the received counter value in the Simulink on the right side and inside of the CoojaPlatform on the left side.
<p align="center">  
<img src="https://kth-gisoo.googlecode.com/svn/trunk/images/samples/dacwriter/DACWriter_CoojaPlatform.png" >
<p>



=== Serial Communication ===
More over to the ADC and DAC, GISOO also support the serial Communication between Simulink and Cooja. The designed procedure in GISOO can provide two types of serial communication in its scenarios. 
  # Mote in Cooja send data via serial port to the Simulink without expecting to receive data from Serial port. 
  # Mote In Cooja send data via serial to the Simulink and it expects to receive a reply serial data from Simulink after a specific amount of time.
The next two example explain each of these methods in details.
==== One Way Serial Communication ====
TinyOS codes: [https://kth-gisoo.googlecode.com/svn/trunk/files/examples/serialcommunication/Modified_TestSerial.zip Download_Modified_TestSerial] 

Simulink Model: [https://kth-gisoo.googlecode.com/svn/trunk/files/examples/serialcommunication/SerialCommunication_OneWay.zip Download_SerialCommunication_OneWay_Simulink_Model] 

Like all the scenario in GISOO this example also contains two parts, TinyOS code and the Simulink model. The provided TinyOS code for this example is a modified version of standard "testserial" code which has located in the  "tinyos-2.x/apps/tests/TestSerial" or you also can download it from [http://www.tinyos.net/tinyos-2.1.0/apps/tests/TestSerial/ here].
The original TestSerial application send a counter value on the serial port every 1 second and also it shows the last three significant byte of the received serial data. This application contain a java program which also generate a counter value on PC and send it to the mote serial port. 
To use this application in GISOO as an example for serial communication we need to do some modification on it and understanding these modification required to understand the message structure for the serial communication in GISOO which will be explained in below:

===== Message structure for the serial communication in GISOO =====
The details of designed messages structure for data transmission between Simulink and Cooja in GISOO has been explained in (?????????????????). But in very short, to understand this part, we should know that GISOO has been designed so that for serial communication between Cooja and Simulink the serial data should have <b>16 bytes structure</b> (The data structure that you define in TinyOS code of your mote to be sent or received via serial should have 16 bytes). It means that the serial data can not be longer than 16 byes (if you need to communicate more than 16 bytes you should divide it to different messages) or also if your message is smaller than 16 byte you still have to define 16 byte data structure but you can leave the unneeded parts, empty. 

For this example in order to adapt the testserial application with the required message type we changed the data structure of the counter message  to make in a 16 bytes structure. In the define code for this scenario in the "TestSerial.h" the serial message data contains 16 bytes as it has shown in the following:

{{{
typedef nx_struct test_serial_msg {
    nx_uint16_t counter;
    nx_uint16_t counter2[7];   //Added to the original structure to convert it to a 16 bytes structure.
} test_serial_msg_t;
}}}

We also removed the java application which were not needed in this scenario and modified the make-file.  
The following figure shows the implemented scenario in GISOO. In this scenario the virtual mote in Cooja will generate a counter value periodically and send it to its mirror mote in Simulink. Then the mirror mote extract the counter value from the received serial message and show it in a scope.
<p align="center">  
<img src="https://kth-gisoo.googlecode.com/svn/trunk/images/samples/serialcommunication/SerialComm_OneWay.png" >
<p>
Following picture shows inside of the CoojaPlatform block in left and the counter valued in scope in right.
<p align="center">  
<img src="https://kth-gisoo.googlecode.com/svn/trunk/images/samples/serialcommunication/SerialComm_OneWay_Result.png" >
<p>

==== Two Ways Serial Communication ====
TinyOS codes: [https://kth-gisoo.googlecode.com/svn/trunk/files/examples/serialcommunication/Modified_TestSerial.zip Download_Modified_TestSerial] 

Simulink Model: [https://kth-gisoo.googlecode.com/svn/trunkfiles/examples/serialcommunication/SerialCommunication_TwoWays.zip Download_SerialCommunication_TwoWay_Simulink_Model] 

As it has been mentioned, another supported type of the serial communication in GISOO is two way communication. In this method first the virtual mote in Cooja will send a serial message to its mirror mote in Simulink and will request for receiving a serial message as reply after specific amount of time. This example explains the required details for this type of serial communication. The TinyOS code that we used for this example is the the "testSerial" application, the same as we used in the previous example. But in this example the serial messages will path a sircle from Cooja to Simulink and then from Simulink to Cooja. In this Scenario the virtual mote in Cooja first will send a counter value via the serial data to its mirror mote in Simulink but it also will request to receive a serial message in 1 ms after the sending the message. On the other side in the Simulink the mirror mote will receive the serial message and extract the counter value but again will send the received counter value via another serial message the mote in Cooja and in the result the virtual mote in Cooja will show the last three bits of the received counter value by with its Leds. 
But in order to receive a serial message back, in Cooja we should select the provided check-box in the GISOO plug-in which will specify the require of receiving the serial message after a specific amount of time which should be mentioned in provided text-box. The general view of the simulated scenario and mentioned check box in the plug-in has been shown in the following figure. It also shows the mote's leds which blink in result of receiving a serial message back from Simulink. 
<p align="center">  
<img src="https://kth-gisoo.googlecode.com/svn/trunk/images/samples/serialcommunication/SerialComm_TwoWays2.png" >
<p>

The following picture shows the inside of the Coojaplatform block in the Simulink model. As you can see the counter value from received serial message will wend back via the serial port to the mote in Cooja. But there are two important points in this model which worse to be mentioned. 
The first point is about the location of counter value in the received serial message. Since in the defined message structure in the testserial.h the first two bytes belongs to the counter value and the rest of the 16 bytes are unused. So when we receive the the serial message in Simulink, the counter value should be rebuild from the first two bytes and also we should put it in the proper location (same location in this scenario) when we want to send it back to mote. You can see the testSerial.h in the following:

{{{

#ifndef TEST_SERIAL_H
#define TEST_SERIAL_H

typedef nx_struct test_serial_msg {
nx_uint16_t counter;
nx_uint16_t counter2[7];

} test_serial_msg_t;

enum {
  AM_TEST_SERIAL_MSG = 6, 
};

#endif
}}}

The other important point, is about the "AM_TEST_SERIAL_MSG" value which is 6 in this sample. This value has been used in the "ModifiedTestSerialAppC" as it has been shown in the following:

{{{
components SerialActiveMessageC as AM;
.
.
.
 App.Receive -> AM.Receive[AM_TEST_SERIAL_MSG];
 App.AMSend -> AM.AMSend[AM_TEST_SERIAL_MSG];
}}} 
This Value will act similar as the port number for the serial message and specify this message belongs to which application. This point is important when we want to send a serial message from Simulink to Cooja because this value should be the same with the its corresponding value in the generated serial message in Simulink otherwise the generated message will be distorted in the mote. So for this aim in the mote parameter in Simulink, there is a value of "Serial Packet Type" which should be set with the same value of AM_TEST_SERIAL_MSG in this sample (6 in this scenario).

<p align="center">  
<img src="https://kth-gisoo.googlecode.com/svn/trunk/images/samples/serialcommunication/SerialComm_TwoWays_CoojaPlatform.png" >
<p>



== Advanced Examples ==
Most of the real scenarios are not only a simple sensor or actuator but they are a mixture of those. For this reason their simulation environment consist of ADC reading and DAC writing and even maybe serial communication together and in this part some these mixed scenarios will be explained.

One of the simplest mixed scenario is only made of combination of ADC and DAC. The schematic of these environment has been shown in the following picture.

<p align="center">  
<img src="https://kth-gisoo.googlecode.com/svn/trunk/images/samples/advancescenarios/ADCDACComm.png" >
<p>




More over to ADC and DAC, GISOO also supports the Serial communication between Simulink and Cooja. This facility make it possible to simulate those systems with the need of powerful processing resource as a  controller. In this situation by using a motes with a "BaseStasion" application which can act as a gateway we can transfer our collected data to a PC where the controlling computation will be done and finally the results can be send back via the serial communication to the wireless system to be used in order to control the plant.


=== double-tank system with the controller on PC ===
In the section "[https://code.google.com/p/kth-gisoo/wiki/How_to_use_it ,How to use GISOO]" we introduced the double-tank system as a "[https://code.google.com/p/kth-gisoo/wiki/How_to_use_it#Simple_Scenario ,simple scenario]". In this section we explain the same simulation scenario but by locating the control process on a PC instead of a mote. The following picture shows both scenarios with controller in a mote or in a PC.


<p align="center">   
<img src="https://kth-gisoo.googlecode.com/svn/trunk/images/samples/serialcommunication/SimpleScenarioMix.png >
<p>

In order to simulate the scenario with the controller on PC first we should create all of our motes  in Cooja, so we should four motes: one Sensor, one relay, one Base-Station and, one actuator. You can download the TinyOS code for the motews from here (?????????????) these codes are exactly the same code as those we had for our simple scenario with the new message structure for the sensor and actuator and also instead of a code for controller we have a modified code for base-station which send the radio messages to the actuator instead of broadcast which will be explained in the following.  

==== Message structure for the serial communication in GISOO ====
The details od designed messages structure for data transmission between Simulink and Cooja in GISOO has been explained in (?????????????????). But in very short, to understand this part, we should know that GISOO has been designed so that for serial communication between Cooja and Simulink the serial data should have <b>16 bytes structure</b> (The data structure that you define in TinyOS code of your mote to be sent or received via serial should have 16 bytes). It means that the serial data can not be longer than 16 byes (if you need to communicate more than 16 bytes you should divide it to different messages) or also if your message is smaller than 16 byte you still have to define 16 byte data structure but you can leave the unneeded parts, empty. For this reason we changed the data struct of the message from sensor to the controller (relay will just forward the message without any modification) to make in a 16 bytes structure. In the define code for this scenario in the "app_parameters.h" the sensor data contains 16 bytes as it has shown in the following:

{{{
// Type of message send by the sensor node to the relay node
typedef struct SensorValues {
	nx_uint16_t tankLevel[8]; // tankLevel[0] for the tank-1 and tankLevel[1] for tank-2 and the rest of the structure will not be used.
} SensorValues;
}}}

For the same reason the message that will be sent from base-station to the actuator also has 16 bytes structure so that the structure of the message that should be received by actuator should also be changed to 16 byte:

{{{
// Type of message send by the controller (base-station) to the actuator node
typedef nx_struct EncMsg2SensorsAct {
	nx_uint16_t u[8]; // Actuation value send to the actuator(from base-station). u[0] contains the actuation value and the rest of the data structure is empty.
}EncMsg2SensorsAct;
}}}

The other point that has been mentioned about the codes in this scenario was the modified base-station. Since we would like to forward all the actuation values from PC to the actuator (not the other motes) we modified the send function of the basestaion so that it just forward the radio messages to the actuator (mote with id:5 in this scenario). As it has been shown in the following code, the "addr" value has been changed to a fix id of actuator mote (5).  
{{{
task void radioSendTask() {
    uint8_t len;
    am_id_t id;
    am_addr_t addr,source;
    message_t* msg;
    
    atomic
      if (radioIn == radioOut && !radioFull)
	{
	  radioBusy = FALSE;
	  return;
	}

    msg = radioQueue[radioOut];
    len = call UartPacket.payloadLength(msg);
    addr = 5;//call UartAMPacket.destination(msg);
    source = call UartAMPacket.source(msg);
    id = call UartAMPacket.type(msg);

    call RadioPacket.clear(msg);
    call RadioAMPacket.setSource(msg, source);
    
    if (call RadioSend.send[id](addr, msg, len) == SUCCESS)
      call Leds.led0Toggle();
    else
      {
	failBlink();
	post radioSendTask();
      }
  }
}}}

After preparing our TinyOS codes we have to create all the motes in Cooja. It has bees shown in the following picture. In this scenario mote-ids has been defined in the "app_parameters.h": 
{{{
        COORDINATOR_ADDRESS	=	4,
	SENSOR_ADDRESS 		=	2,
	ACTUATOR_ADDRESS 	= 	5,
	RELAYNODE_ADDRESS 	= 	3,
}}}

So we have to create the motes with the mentioned id but instead of Coordinator (Controller) we have to create our base-station. After creating, for those motes which needs to be connected to the plant or PC(for controlling purposes) we have to activate the "SimulinkConnector" plug-in. In this scenario sensor needs to sense the water level from the plant, actuator should be able to send the actuataion value to the plant, and also base station should be able to transfer the serial data to the controller model in the PC and receive the results back from that model. As it has shown the SimulinkConnector has been activated for these motes. 


<p align="center">   
<img src="https://kth-gisoo.googlecode.com/svn/trunk/images/samples/serialcommunication/SerialCommunication.png >
<p>

The important point about this scenario is the serial communication which will be performed by using the Base-Station. GISOO support two type of serial communication in its scenarios. 
  # Mote in Cooja send data via serial to the Simulink without expecting to receive data from Serial. (In these types of scenarios The SeimmulinkConnector plug-in will automatically forward the motes serial data to it mirror motes in Simulink)
  # Mote In Cooja send data via serial to the Simulink and it expect to receive a reply serial data from Simulink after a specific amount of time. (In these types of scenarios you have to specify the necessity of receiving the serial reply by selecting the checkBox in the SimmulinkConnector plug-in and also mentioning the specific amount of in the provided testBox.) As you can see in the above picture the checkBox of the plug-in for the baseStation has been ticked and it expect to receive the reply 1 millisecond (default value) after the serial data has been send via the serial to Simulink.

Like all other scenarios in GISOO the other side of simulation should be designed in Simulink. In the Simulink part, the location of plant and the CoojaPlatfor are exactly the same as the simple scenario without serial communication, which has been shown in the following picture.

<p align="center">   
<img src="https://kth-gisoo.googlecode.com/svn/trunk/images/samples/serialcommunication/SimulationModelForSerialCommunication.png>
<p>

The main difference between this scenario and the simple scenario without serial communication is inside the Cooja platform. As it has shown in the following picture in this scenario we have to add another mote as baseStasion to the platform which receives the serial data from its mirror mote in Cooja and forward the data to controller model which will calculate the actuation value according to its input and finally it will send the calculated to the baseStation in order to forward the value to the actuator.

Since in GISOO the serial data should have the fix 16 bytes data structure, the output serial data should be divided to it 16 bytes and then acording to your defined data types you can recreate your data from the serial message. Since in this scenario we send two values as a water levels that each of them has two bytes (the message structure of sensor has been explained previously in this page)

{{{
nx_uint16_t tankLevel[8]; // tankLevel[0] for the tank-1 and  tankLevel[1] for tank-2 
}}}
So after receiving the serial data we have to recreate two water tank values and for this aim we can use the provided blocks in GISOO Simulink Library to generate different data types from bytes.

After generating the water level values we have to use these values as the input of the controller model which has been shown as a block in this model. Finally the results of the model should be sent back to the and we have to convert this value to its corresponding bytes.

The Following picture shows the structure of the Cooja platform for this scenario. The important point that should never be mistaken is the location of the controller model. This model should always be located inside the Cooja Platform. The outside of the Cooja Platform is our <b>physical environment or Plant</b> and the controller model is not part of the plant!   
<p align="center">   
<img src="https://kth-gisoo.googlecode.com/svn/trunk/images/samples/serialcommunication/inside_CoojaPlatform_SerialCommunication.png>
<p>

== CTP Routing Protocol ==
This section will explain an advanced version of previous water-tank scenario with some interesting specification. The main important characteristic of this sample has laid on the routing layer but in overall the main specification of this sample can be listed like this:
  * Using [http://sing.stanford.edu/gnawali/ctp/ , CTP] as a routing protocol in a scenario and simulate it in the GISOO.
  * Creating a scenario with several number of motes and different connections between Simulink an Cooja.
  * Creating a single simulation containing several plants.
=== Multiple tanks scenario ===
In this scenario we simulate a water tank laboratory which contains 10 different double tanks and all of them will work in parallel and be controlled by single central controller. In fact this is a simulation of our water tank laboratory which has been shown in the following picture:
[??????????????????????????????????????????????????????????]

In this scenario since we have 10 sets of double tanks, we will need 10 mote to receive the sensor data from each set, 10 actuators that can actuate the motor in each set separately, 1 mote as a central controller and 17 relays to forward the sensor data to the central controller. In this scenario mote-ids 1 - 10 belong to sensors, 21 - 30 belongs to actuators, controller has mote-id 41 and relay are 42 - 58 

On the other hand in order to use CTP as dynamic routing protocol between sensors and controller we modified the code of the simple tank scenario and by adding the CTP to its structure. You can download the TinOS codes for this scenario from here[??????????????].

Finally the created scenario in Cooja will be like the following picture. The GISOO plug-in (SimulinkConnector) become activated for all the sensors and actuators. The picture also shows the "Radio messages" logger which can be activated from "Tools" menu. This is one of the great plug-ins in Cooja which shows all radio messages during the simulation with complete details.

<p align="center">   
<img src="https://kth-gisoo.googlecode.com/svn/trunk/images/samples/CTP/Cooja_LargeScenario.png>
<p>

The GISOO environment in Simulink contains of One Cooja platform and 10 separate plant that each of them act as one set of double tank. The following picture shows the GISOO environment in Simulink.

<p align="center">   
<img src="https://kth-gisoo.googlecode.com/svn/trunk/images/samples/CTP/Simulink_LargeScenario.png>
<p>

Inside the COoja platform block in Simulink, we added one mote in mirror of each sensor and actuator in the Cooja. It is necessary to emphasize that a mirror mote is a mote with same mote-id which act the same as the mote with Id do in the other environment. 

<p align="center">   
<img src="https://kth-gisoo.googlecode.com/svn/trunk/images/samples/CTP/CoojaPaltform_LargeScenario.png>
<p>

Results for this scenario and some other similar scenarios which contains the interference or mote removal has been explained in our paper[????????????????].