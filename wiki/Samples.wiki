<wiki:toc />
----
= Examples tutorial =
This section provide explanations about different example scenarios. The scenarios have been selected so that they cover different areas. At the beginning it has been tried to show how can use the ADC and DAC in GISOO and in the next step the required details for serial communication has been explained and the usage of serial communication has been shown in a simple example. In the next step the the previous simple scenario has been extended to show the usage of CTP routing protocol in the routing layer. This section tries to provide samples from very simple and basic aspects until advanced scenarios which also can be considered as tutorial for GISOO.
== ADC data transmission in GISOO ==
TinyOS codes: [https://kth-gisoo.googlecode.com/svn/trunk/files/examples/adcreader/ADCReader.zip Download_ADCReader] 

Simulink Model: Download_ADCReader

<p align="center">  
<img src="https://kth-gisoo.googlecode.com/svn/trunk/images/samples/adcreader/ADCReader.png" >
<p>


<p align="center">  
<img src="https://kth-gisoo.googlecode.com/svn/trunk/images/samples/adcreader/ADCReader_CoojaPlatform.png" >
<p>
== DAC data transmission in GISOO ==
TinyOS codes: [https://kth-gisoo.googlecode.com/svn/trunk/files/examples/dacwriter/DACWriter.zip Download_DACWriter] 

Simulink Model: [https://kth-gisoo.googlecode.com/svn/trunk/files/examples/dacwriter/DACWriter_SimulinkModel.zip  Download_DACWriter_SimulinkModel] 
<p align="center">  
<img src="https://kth-gisoo.googlecode.com/svn/trunk/images/samples/dacwriter/DACWriter.png" >
<p>

<p align="center">  
<img src="https://kth-gisoo.googlecode.com/svn/trunk/images/samples/dacwriter/DACWriter_CoojaPlatform.png" >
<p>



== Serial Communication ==
=== One Way Serial Communication ===
=== Two Ways Serial Communication ===


More over to ADC and DAC, GISOO also supports the Serial communication between Simulink and Cooja. This facility make it possible to simulate those systems with the need of powerful processing resource as a  controller. In this situation by using a motes with a "BaseStasion" application which can act as a gateway we can transfer our collected data to a PC where the controlling computation will be done and finally the results can be send back via the serial communication to the wireless system to be used in order to control the plant.

=== double-tank system with the controller on PC ===
In the section "[https://code.google.com/p/kth-gisoo/wiki/How_to_use_it ,How to use GISOO]" we introduced the double-tank system as a "[https://code.google.com/p/kth-gisoo/wiki/How_to_use_it#Simple_Scenario ,simple scenario]". In this section we explain the same simulation scenario but by locating the control process on a PC instead of a mote. The following picture shows both scenarios with controller in a mote or in a PC.


<p align="center">   
<img src="https://kth-gisoo.googlecode.com/svn/trunk/images/samples/serialcommunication/SimpleScenarioMix.png >
<p>

In order to simulate the scenario with the controller on PC first we should create all of our motes  in Cooja, so we should four motes: one Sensor, one relay, one Base-Station and, one actuator. You can download the TinyOS code for the motews from here (?????????????) these codes are exactly the same code as those we had for our simple scenario with the new message structure for the sensor and actuator and also instead of a code for controller we have a modified code for base-station which send the radio messages to the actuator instead of broadcast which will be explained in the following.  

==== Message structure for the serial communication in GISOO ====
The details od designed messages structure for data transmission between Simulink and Cooja in GISOO has been explained in (?????????????????). But in very short, to understand this part, we should know that GISOO has been designed so that for serial communication between Cooja and Simulink the serial data should have <b>16 bytes structure</b> (The data structure that you define in TinyOS code of your mote to be sent or received via serial should have 16 bytes). It means that the serial data can not be longer than 16 byes (if you need to communicate more than 16 bytes you should divide it to different messages) or also if your message is smaller than 16 byte you still have to define 16 byte data structure but you can leave the unneeded parts, empty. For this reason we changed the data struct of the message from sensor to the controller (relay will just forward the message without any modification) to make in a 16 bytes structure. In the define code for this scenario in the "app_parameters.h" the sensor data contains 16 bytes as it has shown in the following:

{{{
// Type of message send by the sensor node to the relay node
typedef struct SensorValues {
	nx_uint16_t tankLevel[8]; // tankLevel[0] for the tank-1 and tankLevel[1] for tank-2 and the rest of the structure will not be used.
} SensorValues;
}}}

For the same reason the message that will be sent from base-station to the actuator also has 16 bytes structure so that the structure of the message that should be received by actuator should also be changed to 16 byte:

{{{
// Type of message send by the controller (base-station) to the actuator node
typedef nx_struct EncMsg2SensorsAct {
	nx_uint16_t u[8]; // Actuation value send to the actuator(from base-station). u[0] contains the actuation value and the rest of the data structure is empty.
}EncMsg2SensorsAct;
}}}

The other point that has been mentioned about the codes in this scenario was the modified base-station. Since we would like to forward all the actuation values from PC to the actuator (not the other motes) we modified the send function of the basestaion so that it just forward the radio messages to the actuator (mote with id:5 in this scenario). As it has been shown in the following code, the "addr" value has been changed to a fix id of actuator mote (5).  
{{{
task void radioSendTask() {
    uint8_t len;
    am_id_t id;
    am_addr_t addr,source;
    message_t* msg;
    
    atomic
      if (radioIn == radioOut && !radioFull)
	{
	  radioBusy = FALSE;
	  return;
	}

    msg = radioQueue[radioOut];
    len = call UartPacket.payloadLength(msg);
    addr = 5;//call UartAMPacket.destination(msg);
    source = call UartAMPacket.source(msg);
    id = call UartAMPacket.type(msg);

    call RadioPacket.clear(msg);
    call RadioAMPacket.setSource(msg, source);
    
    if (call RadioSend.send[id](addr, msg, len) == SUCCESS)
      call Leds.led0Toggle();
    else
      {
	failBlink();
	post radioSendTask();
      }
  }
}}}

After preparing our TinyOS codes we have to create all the motes in Cooja. It has bees shown in the following picture. In this scenario mote-ids has been defined in the "app_parameters.h": 
{{{
        COORDINATOR_ADDRESS	=	4,
	SENSOR_ADDRESS 		=	2,
	ACTUATOR_ADDRESS 	= 	5,
	RELAYNODE_ADDRESS 	= 	3,
}}}

So we have to create the motes with the mentioned id but instead of Coordinator (Controller) we have to create our base-station. After creating, for those motes which needs to be connected to the plant or PC(for controlling purposes) we have to activate the "SimulinkConnector" plug-in. In this scenario sensor needs to sense the water level from the plant, actuator should be able to send the actuataion value to the plant, and also base station should be able to transfer the serial data to the controller model in the PC and receive the results back from that model. As it has shown the SimulinkConnector has been activated for these motes. 


<p align="center">   
<img src="https://kth-gisoo.googlecode.com/svn/trunk/images/samples/serialcommunication/SerialCommunication.png >
<p>

The important point about this scenario is the serial communication which will be performed by using the Base-Station. GISOO support two type of serial communication in its scenarios. 
  #Mote in Cooja send data via serial to the Simulink without expecting to receive data from Serial. (In these types of scenarios The SeimmulinkConnector plug-in will automatically forward the motes serial data to it mirror motes in Simulink)
  #Mote In Cooja send data via serial to the Simulink and it expect to receive a reply serial data from Simulink after a specific amount of time. (In these types of scenarios you have to specify the necessity of receiving the serial reply by selecting the checkBox in the SimmulinkConnector plug-in and also mentioning the specific amount of in the provided testBox.) As you can see in the above picture the checkBox of the plug-in for the baseStation has been ticked and it expect to receive the reply 1 millisecond (default value) after the serial data has been send via the serial to Simulink.

Like all other scenarios in GISOO the other side of simulation should be designed in Simulink. In the Simulink part, the location of plant and the CoojaPlatfor are exactly the same as the simple scenario without serial communication, which has been shown in the following picture.

<p align="center">   
<img src="https://kth-gisoo.googlecode.com/svn/trunk/images/samples/serialcommunication/SimulationModelForSerialCommunication.png>
<p>

The main difference between this scenario and the simple scenario without serial communication is inside the Cooja platform. As it has shown in the following picture in this scenario we have to add another mote as baseStasion to the platform which receives the serial data from its mirror mote in Cooja and forward the data to controller model which will calculate the actuation value according to its input and finally it will send the calculated to the baseStation in order to forward the value to the actuator.

Since in GISOO the serial data should have the fix 16 bytes data structure, the output serial data should be divided to it 16 bytes and then acording to your defined data types you can recreate your data from the serial message. Since in this scenario we send two values as a water levels that each of them has two bytes (the message structure of sensor has been explained previously in this page)

{{{
nx_uint16_t tankLevel[8]; // tankLevel[0] for the tank-1 and  tankLevel[1] for tank-2 
}}}
So after receiving the serial data we have to recreate two water tank values and for this aim we can use the provided blocks in GISOO Simulink Library to generate different data types from bytes.

After generating the water level values we have to use these values as the input of the controller model which has been shown as a block in this model. Finally the results of the model should be sent back to the and we have to convert this value to its corresponding bytes.

The Following picture shows the structure of the Cooja platform for this scenario. The important point that should never be mistaken is the location of the controller model. This model should always be located inside the Cooja Platform. The outside of the Cooja Platform is our <b>physical environment or Plant</b> and the controller model is not part of the plant!   
<p align="center">   
<img src="https://kth-gisoo.googlecode.com/svn/trunk/images/samples/serialcommunication/inside_CoojaPlatform_SerialCommunication.png>
<p>

== CTP Routing Protocol ==
This section will explain an advanced version of previous water-tank scenario with some interesting specification. The main important characteristic of this sample has laid on the routing layer but in overall the main specification of this sample can be listed like this:
  * Using [http://sing.stanford.edu/gnawali/ctp/ , CTP] as a routing protocol in a scenario and simulate it in the GISOO.
  * Creating a scenario with several number of motes and different connections between Simulink an Cooja.
  * Creating a single simulation containing several plants.
=== Multiple tanks scenario ===
In this scenario we simulate a water tank laboratory which contains 10 different double tanks and all of them will work in parallel and be controlled by single central controller. In fact this is a simulation of our water tank laboratory which has been shown in the following picture:
[??????????????????????????????????????????????????????????]

In this scenario since we have 10 sets of double tanks, we will need 10 mote to receive the sensor data from each set, 10 actuators that can actuate the motor in each set separately, 1 mote as a central controller and 17 relays to forward the sensor data to the central controller. In this scenario mote-ids 1 - 10 belong to sensors, 21 - 30 belongs to actuators, controller has mote-id 41 and relay are 42 - 58 

On the other hand in order to use CTP as dynamic routing protocol between sensors and controller we modified the code of the simple tank scenario and by adding the CTP to its structure. You can download the TinOS codes for this scenario from here[??????????????].

Finally the created scenario in Cooja will be like the following picture. The GISOO plug-in (SimulinkConnector) become activated for all the sensors and actuators. The picture also shows the "Radio messages" logger which can be activated from "Tools" menu. This is one of the great plug-ins in Cooja which shows all radio messages during the simulation with complete details.

<p align="center">   
<img src="https://kth-gisoo.googlecode.com/svn/trunk/images/samples/CTP/Cooja_LargeScenario.png>
<p>

The GISOO environment in Simulink contains of One Cooja platform and 10 separate plant that each of them act as one set of double tank. The following picture shows the GISOO environment in Simulink.

<p align="center">   
<img src="https://kth-gisoo.googlecode.com/svn/trunk/images/samples/CTP/Simulink_LargeScenario.png>
<p>

Inside the COoja platform block in Simulink, we added one mote in mirror of each sensor and actuator in the Cooja. It is necessary to emphasize that a mirror mote is a mote with same mote-id which act the same as the mote with Id do in the other environment. 

<p align="center">   
<img src="https://kth-gisoo.googlecode.com/svn/trunk/images/samples/CTP/CoojaPaltform_LargeScenario.png>
<p>

Results for this scenario and some other similar scenarios which contains the interference or mote removal has been explained in our paper[????????????????].